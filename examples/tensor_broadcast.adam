// Tensor-scalar broadcast and element-wise division smoke test.

// Scalar * Tensor
let a = tensor_ones([3]) * 2.0
println(a)
// expect: Tensor<[3]>(2, 2, 2)

// Tensor * Scalar
let b = 3.0 * tensor_ones([3])
println(b)
// expect: Tensor<[3]>(3, 3, 3)

// Tensor + Scalar
let c = tensor_from_array([1, 2, 3], [3]) + 10.0
println(c)
// expect: Tensor<[3]>(11, 12, 13)

// Tensor - Scalar
let d = tensor_from_array([10, 20, 30], [3]) - 5.0
println(d)
// expect: Tensor<[3]>(5, 15, 25)

// Tensor / Scalar
let e = tensor_from_array([10, 20, 30], [3]) / 2.0
println(e)
// expect: Tensor<[3]>(5, 10, 15)

// Tensor / Tensor (element-wise)
let f = tensor_from_array([10, 20, 30], [3])
let g = tensor_from_array([2, 4, 5], [3])
println(f / g)
// expect: Tensor<[3]>(5, 5, 6)

// Row broadcast: [2,3] + [1,3]
let big = tensor_from_array([1, 2, 3, 4, 5, 6], [2, 3])
let bias = tensor_from_array([10, 20, 30], [1, 3])
println(big + bias)
// expect: Tensor<[2, 3]>(11, 22, 33, 14, 25, 36)

// tensor_exp, tensor_log, tensor_relu, tensor_max
let h = tensor_from_array([0, 1, 2], [3])
println(tensor_relu(tensor_from_array([-1, 0, 3], [3])))
// expect: Tensor<[3]>(0, 0, 3)

println(tensor_max(tensor_from_array([3, 7, 2, 9, 1], [5])))
// expect: 9

// tensor_sum_axis: sum columns of a 2x3 matrix
let m = tensor_from_array([1, 2, 3, 4, 5, 6], [2, 3])
println(tensor_sum_axis(m, 0))
// expect: Tensor<[1, 3]>(5, 7, 9)

// tensor_slice: extract row 1 from 2x3 matrix
println(tensor_slice(m, 1, 1))
// expect: Tensor<[1, 3]>(4, 5, 6)

// tensor_one_hot (9 elements, print truncates to 8)
let labels = tensor_from_array([0, 2, 1], [3])
println(tensor_one_hot(labels, 3))
// expect: Tensor<[3, 3]>(1, 0, 0, 0, 0, 1, 0, 1, ...)

// tensor_relu_backward
let z = tensor_from_array([-1, 2, 0, 3], [4])
let dout = tensor_from_array([1, 1, 1, 1], [4])
println(tensor_relu_backward(z, dout))
// expect: Tensor<[4]>(0, 1, 0, 1)
